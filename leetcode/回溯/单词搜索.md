#### å•è¯æœç´¢ [LeetCode-79](https://leetcode.cn/problems/word-search/)

ç»™å®šä¸€ä¸ªÂ m x n äºŒç»´å­—ç¬¦ç½‘æ ¼Â board å’Œä¸€ä¸ªå­—ç¬¦ä¸²å•è¯Â word ã€‚å¦‚æœÂ word å­˜åœ¨äºç½‘æ ¼ä¸­ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚

å•è¯å¿…é¡»æŒ‰ç…§å­—æ¯é¡ºåºï¼Œé€šè¿‡ç›¸é‚»çš„å•å…ƒæ ¼å†…çš„å­—æ¯æ„æˆï¼Œå…¶ä¸­â€œç›¸é‚»â€å•å…ƒæ ¼æ˜¯é‚£äº›æ°´å¹³ç›¸é‚»æˆ–å‚ç›´ç›¸é‚»çš„å•å…ƒæ ¼ã€‚åŒä¸€ä¸ªå•å…ƒæ ¼å†…çš„å­—æ¯ä¸å…è®¸è¢«é‡å¤ä½¿ç”¨ã€‚

![å•è¯æœç´¢](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)
```
è¾“å…¥ï¼šboard = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
è¾“å‡ºï¼štrue
```

![å•è¯æœç´¢](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)
```
è¾“å…¥ï¼šboard = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
è¾“å‡ºï¼štrue
```

![å•è¯æœç´¢](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)
```
è¾“å…¥ï¼šboard = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
è¾“å‡ºï¼šfalse
```

##### èœé¸¡å†™æ³•ğŸ˜ˆ
```js
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function(board, word) {
     // è®°å½•å»é‡
    const used = new Array(board.length).fill(0).map(() => new Array(board[0].length).fill(0));

    function backtrack(start, x, y) {
        if (start == word.length) {
            return true
        }
        // è®°å½•ä½¿ç”¨æƒ…å†µ
        used[x][y] = 1

        // è¿™é‡Œå†™çš„æ˜¯çœŸçš„åƒåœ¾ğŸ˜ˆ
        if (board[x][y - 1] == word[start] && !used[x][y - 1]) {
            if (backtrack(start + 1, x, y - 1)) {
                return true
            }
        }
        if (board[x][y + 1] == word[start] && !used[x][y + 1]) {
            if (backtrack(start + 1, x, y + 1)) {
                return true
            }
        }
        if (board[x - 1] && board[x - 1][y] == word[start] && !used[x - 1][y]) {
            if (backtrack(start + 1, x - 1, y)) {
                return true
            }
        }
        if (board[x + 1] && board[x + 1][y] == word[start] && !used[x + 1][y]) {
            if (backtrack(start + 1, x + 1, y)) {
                return true
            }
        }
        // å›æº¯
        used[x][y] = 0
        return false
    }

    // å…ˆæ‰¾å‡ºç¬¬ä¸€ä¸ªå­—ç¬¦
    for (let i = 0; i < board.length; i++) {
        for (let j = 0; j < board[i].length; j++) {
            const char = board[i][j];
            
            if (char == word[0]) {
                if (backtrack(1, i, j)) {
                    return true
                } 
            }
        }
    }
    return false
};
```

##### gptå†™æ³• 600ms
```js
function exist(board, word) {
  const m = board.length;
  const n = board[0].length;
  const visited = new Array(m).fill(0).map(() => new Array(n).fill(false));

  function backtrack(row, col, index) {
    if (index === word.length) {
      return true; // å•è¯å·²æ‰¾åˆ°
    }

    if (row < 0 || row >= m || col < 0 || col >= n || visited[row][col] || board[row][col] !== word[index]) {
      return false; // è¶Šç•Œã€å·²è®¿é—®è¿‡ã€å­—æ¯ä¸åŒ¹é…
    }

    visited[row][col] = true; // æ ‡è®°å½“å‰ä½ç½®å·²è®¿é—®

    // æ²¿ç€ç›¸é‚»çš„å››ä¸ªæ–¹å‘ç»§ç»­æœç´¢
    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
    for (const [dx, dy] of directions) {
      if (backtrack(row + dx, col + dy, index + 1)) {
        return true; // åœ¨å…¶ä¸­ä¸€ä¸ªæ–¹å‘ä¸Šæ‰¾åˆ°äº†å•è¯
      }
    }

    visited[row][col] = false; // å›æº¯ï¼Œå–æ¶ˆå½“å‰ä½ç½®çš„æ ‡è®°
    return false; // æœªæ‰¾åˆ°å•è¯
  }

  // éå†çŸ©é˜µï¼Œä»æ¯ä¸ªä½ç½®å¼€å§‹æœç´¢
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (backtrack(i, j, 0)) {
        return true; // æ‰¾åˆ°äº†å•è¯
      }
    }
  }

  return false; // æœªæ‰¾åˆ°å•è¯
}
```

##### å®˜æ–¹é¢˜è§£ 100ms
```js
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function(board, word) {
    const chars = new Set(board.toString().split(','));
    for(let char of word){
        if(!chars.has(char)) return false;
    }

    const m = board.length;
    const n = board[0].length;

    const used = new Array(m).fill(false).map(() => new Array(n).fill(false))
    const backTracking = (row, col, nextIndex) => {
      if (nextIndex === word.length) {
        return true
      } 
      const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
      // æ²¿ç€ç›¸é‚»çš„å››ä¸ªæ–¹å‘ç»§ç»­æœç´¢
      for (let i = 0; i < 4; i++) {
          const dir = directions[i]
          const newRow = row + dir[0]
          const newCol = col + dir[1]

          // è¾¹ç•Œ
          if (newRow < m && newRow >= 0 && newCol < n && newCol >= 0) {
            // æ˜¯å¦è®¿é—®è¿‡
            if (used[newRow][newCol]) continue
            // æ˜¯å¦åŒ¹é…
            if (board[newRow][newCol] === word[nextIndex]) {
                // è®°å½•é‡å¤
                used[newRow][newCol] = true
                if (backTracking(newRow, newCol, nextIndex + 1)) return true
                // å›æº¯
                used[newRow][newCol] = false
            }
          }
          
      }
    }
    // æ‰¾å‡ºç¬¬ä¸€ä¸ªå­—ç¬¦
    for(let i = 0; i < m; i++) {
        for(let j = 0; j < n; j++) {
            if (board[i][j] === word[0]) {
              used[i][j] = true
              if (backTracking(i, j, 1)) return true;
              used[i][j] = false
            }
        }
    }
    
    return false
};
```